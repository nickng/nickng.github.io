<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects on Nicholas Ng</title>
    <link>http://www.nickng.io/projects/index.xml</link>
    <description>Recent content in Projects on Nicholas Ng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <atom:link href="http://www.nickng.io/projects/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>BibTeX parser and pretty printer in Go</title>
      <link>http://www.nickng.io/projects/bibtex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.nickng.io/projects/bibtex/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/nickng/bibtex&#34;&gt;nickng/bibtex&lt;/a&gt; is a BibTeX parser and pretty
printer for Go. The main aim is the recreate a bibtex tool for the undocumented
BibTeX format in a modern language that can be backwards compatible with the
existing &lt;code&gt;bibtex&lt;/code&gt; tool in the TeXLive latex distribution.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://prettybib.nickng.io&#34;&gt;prettybib.nickng.io&lt;/a&gt; for a web-based interface.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://godoc.org/github.com/nickng/bibtex&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/nickng/bibtex?status.svg&#34; alt=&#34;GoDoc&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go concurrency verification</title>
      <link>http://www.nickng.io/projects/golang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.nickng.io/projects/golang/</guid>
      <description>

&lt;p&gt;The aim of this line of work is to verify channel-based concurrency interaction
in &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt; using techniques from the research area of
&lt;a href=&#34;https://en.wikipedia.org/wiki/Process_calculus&#34;&gt;process calculi&lt;/a&gt; and
&lt;a href=&#34;https://en.wikipedia.org/wiki/Type_system&#34;&gt;type systems&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nickng/dingo-hunter&#34;&gt;nickng/dingo-hunter&lt;/a&gt; is a static
analyser for Go based on the &lt;a href=&#34;http://golang.org/x/tools/go/ssa&#34;&gt;go/ssa&lt;/a&gt; package
from the Go project. The tool itself is designed to be an interface to Go
programs, performing type inference/model extraction from Go code. Current
analysis frontends include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Communicating Finite State Machines (&lt;a href=&#34;https://github.com/nickng/cfsm&#34;&gt;CFSMs&lt;/a&gt;)
modelling goroutines.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;mi&lt;/strong&gt;ni &lt;strong&gt;Go&lt;/strong&gt; process calculi/type system
(&lt;a href=&#34;https://github.com/nickng/migo&#34;&gt;MiGo&lt;/a&gt;) as a high level, communication-only
abstraction.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;publications&#34;&gt;Publications&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/static-deadlock-detection-for-concurrent-go-by-global-session-graph-synthesis/&#34;&gt;Static Deadlock Detection for Concurrent Go by Global Session Graph
Synthesis&lt;/a&gt; uses the CFSMs synthesis approach.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/fencing-off-go-liveness-and-safety-for-channel-based-programming/&#34;&gt;Fencing off Go: Liveness and Safety for Channel-based Programming&lt;/a&gt;
uses the MiGo approach.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>High performance parallel design based on session programming</title>
      <link>http://www.nickng.io/projects/individual-project/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.nickng.io/projects/individual-project/</guid>
      <description>

&lt;h3 id=&#34;high-performance-parallel-design-based-on-session-programming&#34;&gt;High performance parallel design based on session programming&lt;/h3&gt;

&lt;p&gt;Final year individual project,
&lt;a href=&#34;http://www3.imperial.ac.uk/computing/teaching/prizes/2010/ug#4&#34;&gt;The Detica Prize for Technical Innovation&lt;/a&gt;, 2010&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Supervisor: &lt;a href=&#34;http://www.doc.ic.ac.uk/~yoshida&#34;&gt;Nobuko Yoshida&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Second marker: &lt;a href=&#34;http://www.doc.ic.ac.uk/~wl&#34;&gt;Wayne Luk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;abstract&#34;&gt;Abstract&lt;/h4&gt;

&lt;p&gt;Session programming is a programming model based on the theory of session types,
a typing system for pi-calculus.
Session types is developed to model structured interaction between processes
and correctly typed process will have the property of communication safety.
Session Java (SJ) is a full implementation of session types in Java.
In this project, we aim to introduce the session programming model to Axel,
a heterogeneous cluster with both FPGAs and GPUs as hardware
accelerators to design communication safe parallel algorithms.&lt;/p&gt;

&lt;p&gt;We give an implementation of a parallel algorithm, n-body simulation,
on the Axel cluster, using SJ and FPGAs.
We also give a translation of our SJ n-body simulation into C to get a higher performance.
We find good performance improvements in both implementations,
without compromising safety property of our program.&lt;/p&gt;

&lt;p&gt;Finally, we present a formalisation of two new multichannel SJ primitives for parallel programming.
We use the formalisation to prove the correctness of our n-body implementation
and generalise the proof to a ring topology used by parallel algorithms in SJ.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;report.pdf&#34;&gt;Final Report&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;presentation.pdf&#34;&gt;Presentation&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;related-resources&#34;&gt;Related resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.doc.ic.ac.uk/~wl/icprojects/session.html&#34;&gt;Project description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Publication: &lt;a href=&#34;http://cc.doc.ic.ac.uk/projects/prj_axel/&#34;&gt;AXEL: heterogeneous cluster&lt;/a&gt;
[ &lt;a href=&#34;http://www.doc.ic.ac.uk/~wl/papers/10/fpga10bt.pdf&#34;&gt;pdf&lt;/a&gt; ]&lt;/li&gt;
&lt;li&gt;Publication: &lt;a href=&#34;http://www.doc.ic.ac.uk/~rhu/sessionj-deleg.html&#34;&gt;Session-based Distributed Programming in Java&lt;/a&gt;
[ &lt;a href=&#34;http://www.doc.ic.ac.uk/~rhu/sessionj/hyh08session-based.pdf&#34;&gt;pdf&lt;/a&gt; ]&lt;/li&gt;
&lt;li&gt;Software: &lt;a href=&#34;http://code.google.com/p/sessionj&#34;&gt;sessionj: Session programming with Java&lt;/a&gt;, &lt;a href=&#34;http://www.doc.ic.ac.uk/~rhu/sessionj.html&#34;&gt;Author&amp;rsquo;s page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www3.imperial.ac.uk/computing/teaching/ug/ug-distinguished-projects/2010&#34;&gt;Prize Winning and Distinguished Projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www3.imperial.ac.uk/computing/teaching/prizes/2010/ug&#34;&gt;Undergraduate Computing Prizes 2010&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Publication: &lt;a href=&#34;http://www.doc.ic.ac.uk/~omp08/sj_parallel/&#34;&gt;Safe Parallel Programming with Session Java&lt;/a&gt;,
&lt;em&gt;Departmental Technical report DTR10-14, Oct 2010&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Publication: &lt;a href=&#34;http://www.nickng.io/publications/sj-parallel&#34;&gt;Safe Parallel Programming with Session Java&lt;/a&gt;,
In &lt;em&gt;13th Int&amp;rsquo;l Conference on Coordination Models and Languages &lt;a href=&#34;http://discotec.ru.is/coordination/main&#34;&gt;COORDINATION&lt;/a&gt;), June 2011&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Publication: &lt;a href=&#34;http://www.nickng.io/publications/heart12/&#34;&gt;Session Types: Towards safe and fast reconfigurable programming&lt;/a&gt;,
In &lt;em&gt;3rd Int&amp;rsquo;l Workshop on Highly-Efficient Accelerators and Reconfigurable Technologies (&lt;a href=&#34;http://www.cs.tsukuba.ac.jp/~yoshiki/heart/HEART2012/&#34;&gt;HEART&lt;/a&gt;), June 2012&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Multiparty Session C</title>
      <link>http://www.nickng.io/projects/sessionc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.nickng.io/projects/sessionc/</guid>
      <description>

&lt;p&gt;Session C is a communication-safe programming framework which combines
multiparty session types with the C programming language.&lt;/p&gt;

&lt;h2 id=&#34;publications&#34;&gt;Publications&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/session-types-towards-safe-and-fast-reconfigurable-programming/&#34;&gt;Session Types: Towards safe and fast reconfigurable programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/multiparty-session-c-safe-parallel-programming-with-message-optimisation/&#34;&gt;Multiparty Session C: Safe Parallel Programming with Message Optimisation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;related-resources&#34;&gt;Related resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://github.com/nickng/sessc/&#34;&gt;Session C&lt;/a&gt; on GitHub (&lt;a href=&#34;http://github.com/nickng/sessc/wiki&#34;&gt;wiki&lt;/a&gt;) or &lt;a href=&#34;http://github.com/sessionc/&#34;&gt;as libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;google-poster.pdf&#34;&gt;Google PhD Poster Competition 2013 entry&lt;/a&gt;
Runner-up, 3rd year category&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sesscc.googlecode.com/&#34;&gt;Session C (old repository)&lt;/a&gt; on Google code&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scribble.org&#34;&gt;Scribble project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pabble protocol description language</title>
      <link>http://www.nickng.io/projects/pabble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.nickng.io/projects/pabble/</guid>
      <description>

&lt;p&gt;Pabble is a protocol description language, parametric variant of the
&lt;a href=&#34;http://scribble.org&#34;&gt;Scribble&lt;/a&gt; language, extended for modelling communication
in parallel applications.&lt;/p&gt;

&lt;h2 id=&#34;publications&#34;&gt;Publications&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/pabble-parameterised-scribble-for-parallel-programming/&#34;&gt;Pabble: Parameterised Scribble for Parallel Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/pabble-parameterised-scribble/&#34;&gt;Pabble: parameterised Scribble&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrg.doc.ic.ac.uk/publications/safe-mpi-code-generation-based-on-session-types/&#34;&gt;Protocols by Default: Safe MPI Code Generation based on Session Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;related-resources&#34;&gt;Related resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://scribble.org&#34;&gt;Scribble project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;google-poster.pdf&#34;&gt;Poster&lt;/a&gt; for code generation work&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;pabble-examples&#34;&gt;Pabble examples&lt;/h2&gt;

&lt;h3 id=&#34;pabble-protocols-dwarfs&#34;&gt;Pabble protocols: dwarfs&lt;/h3&gt;

&lt;p&gt;The following &lt;a href=&#34;http://mrg.doc.ic.ac.uk/tools/pabble/&#34;&gt;Pabble&lt;/a&gt; protocols are examples chosen
from am evaluation metic for parallel programming models and architectues called
&lt;a href=&#34;http://view.eecs.berkeley.edu&#34;&gt;dwarfs&lt;/a&gt; from UC Berkeley, details available from
their &lt;a href=&#34;http://dl.acm.org/citation.cfm?id=1562764.1562783&#34;&gt;CACM article&lt;/a&gt;.
The article defines six categories of algorithmic patterns (called dwarfs)
common in HPC applications: Structured Grid, Dense Matrix, Sparse Matrix,
Spectral (FFT), Particle methods, and Unstructured Grid. Each of the protocols
below belong to one of the categories.&lt;/p&gt;

&lt;h4 id=&#34;n-body-simulation&#34;&gt;N-Body simulation&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;global protocol NBody(role W[0..N]) {
    rec LOOP {
        (float) from Worker[i:0..N-1] to W[i+1];
        (float) from Worker[N] to W[0];
        /* Calculate Velocity */
        continue LOOP; 
    }
    /* Calculate Step */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dynamic-load-balancing&#34;&gt;Dynamic load balancing&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;global protocol LoadBalancing(role Worker[0..N]) {
    rec REPEAT {
        oneof (Worker[i in 1..N]) {
            request() from Worker[i] to Worker[0];
            choice at Worker[0] {
                finish() from Worker[0] to Worker[i];
                foreach (x:1..N except i) {
                    request() from Worker[x] to Worker[0];
                    finish() from Worker[0] to Worker[x]; 
                }
            } or {
                reply() from Worker[0] to Worker[i]; continue REPEAT;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dense-matrix-vector-multiplication&#34;&gt;Dense matrix-vector multiplication&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;global protocol DenseMatVec(role Worker[0..N]) {
    // Scatter Matrix A
    foreach (i:1..N) {
        LBound(int) from Worker[0] to Worker[i];
        UBound(int) from Worker[0] to Worker[i];
        Data(double) from Worker[0] to Worker[i];
    }
    // Scatter Vector B
    (double) from Worker[0] to Worker[1..N];
    // --- Perform calculation ---
    // Gather data
    (double) from Worker[1..N] to Worker[0];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sparse-matrix-vector-multiplication&#34;&gt;Sparse matrix-vector multiplication&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;global protocol SparseMatVec(role PE[0..N]) {
    /* Distribute data */
    (int) from W[0] to W[1..N]; // row_ptr
    (int) from W[0] to W[1..N]; // col_ind
    (double) from W[0] to W[1..N]; // vals
    (double) from W[0] to W[1..N]; // vector
    /* Output vector */
    (double) from W[1..N] to W[0];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fast-fourier-transformation-fft&#34;&gt;Fast-Fourier Transformation (FFT)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;const N = 3;
global protocol FFT(role W[0..7]) {
    foreach (r:0..N-1) {
        foreach (i:0..2&amp;lt;&amp;lt;N-1) {
            Label(int) from Worker[i] to Worker[i - (i/1&amp;lt;&amp;lt;r)%2 * 1&amp;lt;&amp;lt;(r+1) + 1&amp;lt;&amp;lt;r];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;linear-equation-solver&#34;&gt;Linear Equation Solver&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;global protocol Solver(role W[1..N][1..N], group Col={W[1..N][1]}) {
    rec CONVERGE {
        Ring(double) from W[i:1..N][j:1..N-1] to W[i][j+1];
        Ring(double) from W[i:1..N][N] to W[i][1];

        // Vertical propagation
        (double) from Col to Col;
        continue CONVERGE; 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;monte-carlo-pi-simulation&#34;&gt;Monte-Carlo Pi simulation&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-pabble&#34;&gt;global protocol MonteCarloPi(role Worker[0..N]) {
    // Calculation per process
    Count(int) from Worker[0] to Worker[1..N];
    Result(double) from Worker[1..N] to Worker[0];
    // Final result calculated at Worker[0];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>async-π</title>
      <link>http://www.nickng.io/projects/asyncpi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.nickng.io/projects/asyncpi/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/nickng/asyncpi&#34;&gt;nickng/asyncpi&lt;/a&gt; is a mini-language modelled
after the asynchronous π-calculus implemented in Go intended to be used as a
teaching language.&lt;/p&gt;

&lt;p&gt;The basic syntax is given below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P,Q ::= 0           nil process
      | P|Q         parallel composition of P and Q
      | (new a)P    generation of a with scope P
      | !P          replication of P, infinite parallel composition  P|P|P...
      | u&amp;lt;v&amp;gt;        output of v on channel u
      | u(x).P      input of distinct variables x on u, with continuation P
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://godoc.org/github.com/nickng/asyncpi&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/nickng/asyncpi?status.svg&#34; alt=&#34;GoDoc&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>